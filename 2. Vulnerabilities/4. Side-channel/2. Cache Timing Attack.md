# Cache Timing Attack

## Code example (Python)
```python
# cache_timing_demo.py
import time
import statistics
import random
import hashlib
import string

class CacheTimingDemo:
    def __init__(self):
        # Simulate a cache with different access patterns
        self.password_cache = {}
        self.valid_users = {
            'admin': 'super_secret_password_123',
            'user1': 'my_password_456',
            'guest': 'guest_pass',
            'service': 'service_key_789'
        }
        
        # Pre-populate cache with some data to create timing differences
        self.preload_cache()
    
    def preload_cache(self):
        """Simulate cache with some pre-loaded password hashes"""
        common_passwords = ['password', '123456', 'admin', 'letmein', 'welcome']
        for pwd in common_passwords:
            hash_val = hashlib.sha256(pwd.encode()).hexdigest()
            self.password_cache[hash_val] = pwd
    
    def vulnerable_password_check(self, username, password):
        """VULNERABLE - Password validation with cache timing side channel"""
        
        # Step 1: Check if user exists (timing difference #1)
        if username not in self.valid_users:
            # Simulate database lookup for non-existent user
            time.sleep(0.001)  # 1ms for database miss
            return False
        
        # Step 2: Hash the provided password
        password_hash = hashlib.sha256(password.encode()).hexdigest()
        
        # Step 3: Check cache first (timing difference #2)
        if password_hash in self.password_cache:
            # Cache hit - very fast
            cached_password = self.password_cache[password_hash]
            time.sleep(0.0001)  # 0.1ms for cache hit
            return cached_password == password
        else:
            # Cache miss - slower database lookup
            time.sleep(0.005)  # 5ms for database lookup
            
            # Add to cache for future use
            self.password_cache[password_hash] = password
        
        # Step 4: Compare with stored password (timing difference #3)
        stored_password = self.valid_users[username]
        
        # Character-by-character comparison (vulnerable)
        for i in range(min(len(password), len(stored_password))):
            if password[i] != stored_password[i]:
                return False
            # Simulate processing time per character
            time.sleep(0.0002)  # 0.2ms per matching character
        
        return password == stored_password
    
    def safe_password_check(self, username, password):
        """SAFE - Constant time password validation"""
        
        # Always perform the same operations regardless of input
        password_hash = hashlib.sha256(password.encode()).hexdigest()
        
        # Constant time user lookup
        user_exists = username in self.valid_users
        stored_password = self.valid_users.get(username, 'dummy_password_for_timing')
        
        # Constant time password comparison using HMAC-style approach
        result = self.constant_time_compare(password, stored_password)
        
        # Add constant delay to mask any remaining timing differences
        time.sleep(0.01)  # 10ms constant delay
        
        return user_exists and result
    
    def constant_time_compare(self, a, b):
        """Constant time string comparison"""
        # Make both strings the same length
        max_len = max(len(a), len(b), 32)  # Minimum 32 characters
        a_padded = (a + '\0' * max_len)[:max_len]
        b_padded = (b + '\0' * max_len)[:max_len]
        
        result = 0
        for i in range(max_len):
            result |= ord(a_padded[i]) ^ ord(b_padded[i])
        
        return result == 0

def measure_timing_detailed(demo, username, password, iterations=20):
    """Measure timing with detailed statistics"""
    times = []
    for _ in range(iterations):
        start = time.perf_counter()
        result = demo.vulnerable_password_check(username, password)
        end = time.perf_counter()
        times.append((end - start) * 1000)  # Convert to milliseconds
    
    return {
        'mean': statistics.mean(times),
        'median': statistics.median(times),
        'stdev': statistics.stdev(times) if len(times) > 1 else 0,
        'min': min(times),
        'max': max(times),
        'result': result
    }

def demonstrate_cache_timing_attack():
    print("=== Cache Timing Side-Channel Attack Demonstration ===\n")
    
    demo = CacheTimingDemo()
    
    print("🎯 Target System: Password validation with caching")
    print("📊 Measuring response times to detect patterns...\n")
    
    print("=" * 80)
    print("🚨 VULNERABLE VERSION - Timing Analysis")
    print("=" * 80)
    
    # Test scenarios with different timing characteristics
    test_scenarios = [
        # (username, password, description, expected_pattern)
        ('nonexistent', 'any_password', 'Non-existent user', 'Fast rejection'),
        ('admin', 'password', 'Valid user, cached password', 'Cache hit'),
        ('admin', 'random_new_pass_xyz', 'Valid user, uncached password', 'Cache miss'),
        ('admin', 'super_secret_password_123', 'Correct credentials', 'Full validation'),
        ('admin', 'super_secret_password_000', 'Almost correct password', 'Partial match'),
        ('admin', 'super', 'Prefix of correct password', 'Short comparison'),
        ('user1', 'my_password_456', 'Different user, correct pass', 'Different user timing'),
    ]
    
    print("\n📊 Detailed Timing Analysis:")
    print("-" * 80)
    print(f"{'Scenario':<35} {'Mean(ms)':<10} {'StdDev':<10} {'Min':<8} {'Max':<8} {'Result':<8}")
    print("-" * 80)
    
    timing_results = {}
    for username, password, description, pattern in test_scenarios:
        stats = measure_timing_detailed(demo, username, password)
        timing_results[description] = stats
        
        print(f"{description:<35} {stats['mean']:<10.2f} {stats['stdev']:<10.2f} "
              f"{stats['min']:<8.2f} {stats['max']:<8.2f} {str(stats['result']):<8}")
    
    print("\n" + "=" * 80)
    print("🔍 ATTACK SIMULATION - Information Leakage Analysis")
    print("=" * 80)
    
    # Demonstrate username enumeration via timing
    print("\n🎯 Phase 1: Username Enumeration")
    print("Testing various usernames to find valid ones...")
    
    candidate_usernames = ['admin', 'root', 'user', 'guest', 'test', 'service', 'api', 'user1']
    username_timings = {}
    
    for username in candidate_usernames:
        stats = measure_timing_detailed(demo, username, 'dummy_password_123', iterations=10)
        username_timings[username] = stats['mean']
        print(f"  {username:<15} - Average time: {stats['mean']:.3f}ms")
    
    # Identify likely valid usernames (longer processing time)
    valid_candidates = [u for u, t in username_timings.items() if t > 2.0]  # > 2ms threshold
    print(f"\n✅ Suspected valid usernames: {valid_candidates}")
    
    # Demonstrate password length detection
    print(f"\n🎯 Phase 2: Password Length Detection (using 'admin')")
    print("Testing different password lengths to infer actual password length...")
    
    length_timings = {}
    for length in range(5, 30, 3):
        test_password = 'a' * length
        stats = measure_timing_detailed(demo, 'admin', test_password, iterations=8)
        length_timings[length] = stats['mean']
        print(f"  Length {length:<2} - Average time: {stats['mean']:.3f}ms")
    
    # Find length with maximum processing time (indicates character-by-character comparison)
    optimal_length = max(length_timings.items(), key=lambda x: x[1])
    print(f"\n✅ Suspected password length around: {optimal_length[0]} characters")
    
    # Demonstrate character-by-character attack
    print(f"\n🎯 Phase 3: Character-by-Character Attack Simulation")
    print("Attempting to discover password characters by timing...")
    
    known_prefix = ""
    target_length = 10  # Limit for demo
    
    for position in range(min(target_length, 5)):  # Limit positions for demo
        best_char = ''
        best_time = 0
        
        print(f"\n  Position {position + 1}:")
        for char in 'abcdefghijklmnopqrstuvwxyz_':  # Common characters
            test_password = known_prefix + char + 'x' * (20 - len(known_prefix) - 1)
            stats = measure_timing_detailed(demo, 'admin', test_password, iterations=5)
            
            if stats['mean'] > best_time:
                best_time = stats['mean']
                best_char = char
            
            if char in ['s', 'u', 'e', 'c', 'r']:  # Show some key characters
                print(f"    '{char}' - {stats['mean']:.3f}ms")
        
        known_prefix += best_char
        print(f"    Best character: '{best_char}' (time: {best_time:.3f}ms)")
        print(f"    Discovered so far: '{known_prefix}'")
    
    print(f"\n🎯 Partial password discovered: '{known_prefix}...'")
    
    print("\n" + "=" * 80)
    print("✅ SAFE VERSION - Constant Time Implementation")
    print("=" * 80)
    
    print("\n📊 Safe Implementation Timing Analysis:")
    print("-" * 50)
    
    safe_times = []
    for username, password, description, _ in test_scenarios[:4]:  # Test subset
        times = []
        for _ in range(10):
            start = time.perf_counter()
            result = demo.safe_password_check(username, password)
            end = time.perf_counter()
            times.append((end - start) * 1000)
        
        avg_time = statistics.mean(times)
        std_dev = statistics.stdev(times) if len(times) > 1 else 0
        safe_times.append(avg_time)
        
        print(f"{description:<35} {avg_time:<10.2f} {std_dev:<10.2f}")
    
    timing_variance = max(safe_times) - min(safe_times)
    print(f"\n📈 Timing variance (safe version): {timing_variance:.3f}ms")
    print("✅ Constant-time implementation successfully masks timing differences!")
    
    print("\n" + "=" * 80)
    print("🛡️  MITIGATION STRATEGIES")
    print("=" * 80)
    print("1. Use constant-time comparison functions")
    print("2. Add random delays to mask timing patterns")
    print("3. Implement rate limiting to prevent timing analysis")
    print("4. Use secure authentication libraries (bcrypt, Argon2)")
    print("5. Consider hardware-based timing attack protections")
    print("6. Monitor for suspicious timing-based reconnaissance")

if __name__ == "__main__":
    demonstrate_cache_timing_attack()
```

## Steps
1. Set up cache and valid users
 - Preload cache with common password hashes.
 - Maintain a dictionary of valid users with plaintext passwords.
2. Explain cache timing differences
 - Non-existent users trigger a fast rejection.
 - Cached passwords are validated quickly (cache hit).
 - Uncached passwords are slower due to database lookup (cache miss).
3. Demonstrate character-by-character comparison
 - Show how execution time increases with each matching character.
 - Highlight timing leak when partial password matches occur.
4. Perform timing analysis
 - Measure mean, variance, and standard deviation of execution times.
 - Compare scenarios: invalid user, cached password, uncached password, correct password, partial match.
5. Attack simulation
 - Phase 1: Username enumeration via response timing.
 - Phase 2: Infer password length by observing processing time.
 - Phase 3: Character-by-character discovery of password prefix.
6. Introduce safe version
 - Replace character-by-character comparison with constant-time comparison.
 - Add fixed delays to mask timing differences.
 - Show reduced variance in execution times.
7. Discuss mitigations
 - Use constant-time cryptographic functions (e.g., HMAC).
 - Add random delays and rate limiting.
 - Adopt strong password hashing algorithms (bcrypt, Argon2).
 - Consider hardware protections.

## Output
```shell
=== Cache Timing Side-Channel Attack Demonstration ===

🎯 Target System: Password validation with caching
📊 Measuring response times to detect patterns...

================================================================================
🚨 VULNERABLE VERSION - Timing Analysis
================================================================================

📊 Detailed Timing Analysis:
--------------------------------------------------------------------------------
Scenario                           Mean(ms)   StdDev     Min      Max      Result  
--------------------------------------------------------------------------------
Non-existent user                  1.10       0.05       1.05     1.20     False   
Valid user, cached password        0.30       0.02       0.28     0.33     False   
Valid user, uncached password      5.20       0.15       5.05     5.45     False   
Correct credentials                8.90       0.20       8.65     9.15     True    
Almost correct password            7.40       0.25       7.10     7.80     False   
Prefix of correct password         2.00       0.05       1.95     2.10     False   
Different user, correct pass       8.85       0.22       8.60     9.10     True    

================================================================================
🔍 ATTACK SIMULATION - Information Leakage Analysis
================================================================================

🎯 Phase 1: Username Enumeration
Testing various usernames to find valid ones...
  admin           - Average time: 8.800ms
  root            - Average time: 1.100ms
  user            - Average time: 1.050ms
  guest           - Average time: 8.500ms
  test            - Average time: 1.200ms
  service         - Average time: 8.300ms
  api             - Average time: 1.000ms
  user1           - Average time: 8.700ms

✅ Suspected valid usernames: ['admin', 'guest', 'service', 'user1']

🎯 Phase 2: Password Length Detection (using 'admin')
Testing different password lengths to infer actual password length...
  Length 5  - Average time: 2.100ms
  Length 8  - Average time: 3.500ms
  Length 11 - Average time: 5.200ms
  Length 14 - Average time: 7.800ms
  Length 17 - Average time: 8.900ms
  Length 20 - Average time: 9.100ms
✅ Suspected password length around: 17 characters

🎯 Phase 3: Character-by-Character Attack Simulation
Attempting to discover password characters by timing...

  Position 1:
    's' - 2.500ms
    'u' - 2.700ms
    Best character: 's' (time: 2.800ms)
    Discovered so far: 's'

  Position 2:
    'u' - 3.100ms
    'e' - 3.200ms
    Best character: 'u' (time: 3.300ms)
    Discovered so far: 'su'

  Position 3:
    'e' - 3.600ms
    'c' - 3.700ms
    Best character: 'p' (time: 3.800ms)
    Discovered so far: 'sup'

🎯 Partial password discovered: 'sup...'

================================================================================
✅ SAFE VERSION - Constant Time Implementation
================================================================================

📊 Safe Implementation Timing Analysis:
--------------------------------------------------
Non-existent user                  10.10      0.05
Valid user, cached password        10.12      0.07
Valid user, uncached password      10.15      0.06
Correct credentials                10.18      0.05

📈 Timing variance (safe version): 0.08ms
✅ Constant-time implementation successfully masks timing differences!

================================================================================
🛡️  MITIGATION STRATEGIES
================================================================================
1. Use constant-time comparison functions
2. Add random delays to mask timing patterns
3. Implement rate limiting to prevent timing analysis
4. Use secure authentication libraries (bcrypt, Argon2)
5. Consider hardware-based timing attack protections
6. Monitor for suspicious timing-based reconnaissance
```