# Threats racde condition

## Code example (Python)

```python
# race_condition_demo.py
import threading
import time
import random

class BankAccount:
    def __init__(self, initial_balance=1000):
        self.balance = initial_balance
        self.lock = threading.Lock()  # For safe version
    
    def withdraw_unsafe(self, amount, thread_id):
        """Unsafe withdrawal - race condition possible"""
        print(f"Thread {thread_id}: Checking balance...")
        if self.balance >= amount:
            print(f"Thread {thread_id}: Balance sufficient ({self.balance}), withdrawing {amount}")
            # Simulate network delay or processing time
            time.sleep(random.uniform(0.1, 0.3))
            self.balance -= amount
            print(f"Thread {thread_id}: Withdrawal complete. New balance: {self.balance}")
            return True
        else:
            print(f"Thread {thread_id}: Insufficient funds")
            return False
    
    def withdraw_safe(self, amount, thread_id):
        """Safe withdrawal with locking"""
        with self.lock:
            print(f"Thread {thread_id}: Acquired lock, checking balance...")
            if self.balance >= amount:
                print(f"Thread {thread_id}: Balance sufficient ({self.balance}), withdrawing {amount}")
                time.sleep(random.uniform(0.1, 0.3))
                self.balance -= amount
                print(f"Thread {thread_id}: Withdrawal complete. New balance: {self.balance}")
                return True
            else:
                print(f"Thread {thread_id}: Insufficient funds")
                return False

def demonstrate_race_condition():
    print("=== Race Condition Demonstration ===\n")
    
    # Unsafe version
    print("UNSAFE VERSION (Race Condition Possible):")
    account1 = BankAccount(1000)
    
    threads = []
    for i in range(3):
        thread = threading.Thread(
            target=account1.withdraw_unsafe, 
            args=(800, i+1)
        )
        threads.append(thread)
    
    for thread in threads:
        thread.start()
    
    for thread in threads:
        thread.join()
    
    print(f"Final balance (unsafe): {account1.balance}")
    print("\n" + "="*50 + "\n")
    
    # Safe version
    print("SAFE VERSION (With Locking):")
    account2 = BankAccount(1000)
    
    threads = []
    for i in range(3):
        thread = threading.Thread(
            target=account2.withdraw_safe, 
            args=(800, i+1)
        )
        threads.append(thread)
    
    for thread in threads:
        thread.start()
    
    for thread in threads:
        thread.join()
    
    print(f"Final balance (safe): {account2.balance}")

if __name__ == "__main__":
    demonstrate_race_condition()
```

## Step
1. Explain the concept of race conditions in concurrent programming
2. Show how multiple threads can interfere with shared resources
3. Run the unsafe version multiple times to show inconsistent results
4. Explain time-of-check vs time-of-use vulnerabilities
5. Demonstrate the safe version with proper locking
6. Discuss real-world implications (banking, file systems, etc.)

## Output
```shell
=== Race Condition Demonstration ===

UNSAFE VERSION (Race Condition Possible):
Thread 1: Checking balance...
Thread 2: Checking balance...
Thread 3: Checking balance...
Thread 1: Balance sufficient (1000), withdrawing 800
Thread 2: Balance sufficient (1000), withdrawing 800
Thread 3: Balance sufficient (1000), withdrawing 800
Thread 1: Withdrawal complete. New balance: 200
Thread 2: Withdrawal complete. New balance: -600
Thread 3: Withdrawal complete. New balance: -1400
Final balance (unsafe): -1400

==================================================

SAFE VERSION (With Locking):
Thread 1: Acquired lock, checking balance...
Thread 1: Balance sufficient (1000), withdrawing 800
Thread 1: Withdrawal complete. New balance: 200
Thread 2: Acquired lock, checking balance...
Thread 2: Insufficient funds
Thread 3: Acquired lock, checking balance...
Thread 3: Insufficient funds
Final balance (safe): 200
```
